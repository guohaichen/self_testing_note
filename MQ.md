### RocketMQ 

[官网][https://rocketmq.apache.org/zh/docs/]

#### 消息丢失

- **生产者端**使用`事务消息机制`保证消息零丢失；

- **Broker**配置同步刷盘: RocketMQ提供了在Broker配置中设置同步刷盘的选项。在同步刷盘配置生效后，Broker在接收到生产者发送的消息后，会立即将消息`持久化到磁盘上的CommitLog`文件，并等待刷盘完成后再返回确认消息给生产者。

- **消费者端**使用同步消费机制: 在消费者端，选择使用`同步消费机制来确保消息不丢失`。在同步消费模式下，消费者一次只消费一条消息，并等待消息处理完成后再继续下一条消息的消费。

#### 消息的重复消费

> 举例：生产者生产一个订单消息，短信消费组需要发送短信给用户通知订单，积分消费组则需要增加积分等；而这个订单已经被这两个消费组消费后： 
>
> 1. 由于网络异常或消息传输失败或超时，生产者可能会重新发送消息；
> 2. 消费者应用或异常退出或重启它可能会重新从上一次消费的位置开始消费消息；
> 3. 消费者组变更或消费者实例变更，例如新增或溢出消费者实例，RocketMQ会重新负载均衡，这个过程，可能已经消费的消息会被重新分配给新的消费者实例。都会产生消息的重复消费问题。
>
> 解决方法如下：

1. 幂等，消费任意次消息所产生的影响与执行一次产生的效果一致。
2. 使用消息的唯一标识，可以根据消息的唯一表示来判断是否已经消费过改消息，例如存放在redis中，不为空则代表消费过；

#### 消息堆积

> 消息堆积又分为 **Producer端生产过快**/ **Consumer消费过慢**；

Consumer端消息堆积：

1. 增加消费者实例；
2. 调整消费者组的消费速率，如增加消费线程数，并发度等；
3. 优化消费端的处理逻辑；



#### 顺序消费消息

> 顺序消息分为**局部顺序**和**全局顺序**（吞吐量和性能太差，如要保证全局顺序建议别用mq了）；

1. **Producer端**顺序发送：确保需要顺序发送的消息发送在同一个队列（局部顺序）。（针对需要顺序的消息使用相同key等，再哈希取模发送指定topic，*但是随着topic的创建或服务不可用，哈希改变后也会导致不是顺序发送*）
2. **Consumer端**顺序消费：每个消费者线程只消费一个消息队列中的消息，这样保证消息的顺序性。当消费者线程正在处理一条消息时，不会继续消费其他消息，直到当前消息处理完成。

#### 事务消息机制

> ![事务消息](./MQ.assets/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png)
>
> 1. 生产者将消息发送至 rocketMQ 服务端;
> 2. rocketMQ 服务端将消息持久化成功之后，向生产者返回`ACK`确认消息已经发送成功。此时消息被标记为**暂不能投递**，这种状态下的消息即为**半事务消息**;
> 3. 生产者开始执行本地事务逻辑。
> 4. `生产者`根据本地事务执行结果向服务端`提交二次确认结果`（Commit或Rollback），服务端收到确认结果后处理逻辑如下：
>     - 二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。
>     - 二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。
> 5. 在断网或者是生产者应用重启的特殊情况下，若服务端未收到生产者提交的二次确认结果，或服务端收到的二次确认结果未unkonwn未知状态，经过固定时间，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。
> 6. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
> 7. 生产者根据检查到的本地事务的最终状态再次提交二次确认，根据确认结果对事务消息进行处理。