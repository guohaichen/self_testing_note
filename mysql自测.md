### innoDB

#### 1. MySQL存储引擎的对比

MySQL的存储引擎有InnoDB，MyISAM；InnoDB是MySQL5.5之后默认的存储引擎，它相比MyISAM具有如下特点：

1. 支持事务
2. 支持外键约束
3. 支持表锁和行级锁，而MyISAM只支持表锁

#### 2. 介绍一下数据库的事务

<<<<<<< HEAD
事务是一组原子性的SQL查询，事务内的语句，要么全部执行成功，要么全部执行失败。

InnoDB是一个支持ACID事务的存储引擎。ACID分为为一致性、隔离性、持久性、原子性。 
=======

**一致性**：事务完成时，必须所有的数据都保持一致状态，例如A给B转账，A扣费的同时且B要入账；

**隔离性**：事务执行过程中，事物间的操作对对方来说是不可见的；

**持久性**：事务执行完成后，对数据库的修改是永久保存的；

**原子性**：事务是一个原子操作单元，要么全部成功，要么全部回滚到事务开始前的状态，如果事务中的任何一步失败，整个事务将回滚，以保证事务的一致性；

#### 3. InnoDB是如何实现ACID的

<<<<<<< HEAD
​	通过 mvcc +锁机制实现隔离性，通过 redo log二进制日志实现持久性，使得能在断电，宕机情况下自动恢复数据，通过 undo log回滚日志实现原子性，这三特性实现才能实现数据的一致性；
=======
通过 **mvcc+锁机制实现事务的隔离性**；通过redo log二进制日志实现持久性，使得能在断电，宕机情况下自动恢复数据；通过undo log回滚文件实现原子性；这三特性实现才能实现数据的一致性；
>>>>>>> 69288556b76cac8c7aaf2adf60c28ef8afd9e5d3

#### 4. 并发事务带来了哪些问题?

- **脏读**：一个事务读取到了另一个未提交事务的数据；

- **不可重复读**：在一个事务中，多次读取同一个数据可能得到不同的结果，这是由于读取到了另一个事务对数据的<font color='red'>修改或删除</font>；
- **幻读**：指在当前事务中，另一个并发事务<font color=red>插入</font>了一些数据并提交，随后在当前事务中，查询出之前本没有的数据，好像出现了幻觉，称之为幻读；
- **丢失修改**：当两个事务对同一数据进行修改时，并且最终只有一个事务生效时，另一个事务的修改丢失，称之为丢失修改；
- **死锁**：两个事务持有对方需要的资源，互相等待，称之为死锁，需要数据库管理系统检测并释放；

#### 5. 事务的隔离级别有哪些?InnoDB默认的事务隔离级别？分别会导致哪些问题？

- **读未提交RU**：一个事务中可以读取另一个事务未提交的数据；
- **读已提交RC**：一个事务中能读取另一个已提交事务的数据；（当前读）
- **可重复读RR**：一个事务只能读取当前事务的数据；（默认）（快照读）
- **串行读**：事务串行化执行，绝对的数据安全，效率最低；

| 隔离级别/并发事务问题 | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| 读未提交              | √    | √          | √    |
| 读已提交              | ×    | √          | √    |
| 可重复读              | ×    | ×          | √    |
| 串行化读              | ×    | ×          | ×    |

**InnoDB默认的事务隔离级别为可重复读，并且使用MVCC+锁解决了幻读的问题；**

详细步骤：

1. 读取时加锁：当一个事务开始读取数据时，InnoDB会对所涉及的数据进行加锁，以确保在事务结束之前其他事务不能修改这些数据。这种锁为**<font color = red>共享锁（S锁）</font>**,允许多个事务同时读取同一数据行，但阻止其他事务对数据进行修改；
2. 写入时加锁：当一个事务开始写入（插入、删除或更新）数据时，InnoDB会对所涉及的数据进行加锁，以防止其他事务同时读取或写入数。这种锁称为**<font color = red>排他锁（x锁）</font>**,它在事务结束之前会阻止其他事务对数据行的读取和写入。
3. 生成快照：在可重复读隔离级别下，InnoDB会为每个事务生成一个**快照**（Snapshot），用于读取数据时保持一致性视图。
4. 版本控制：当一个事务开始读取数据时，InnoDB会根据**<font color=red>事务的启动时间和快照</font>**来确定可见的数据版本。只有在事务启动前已提交的数据版本才是可见的，未提交的或在事务启动后修改的数据版本对于当前事务是不可见的。
5. 防止幻读：InnoDB在可重复读隔离级别下还使用了**<font color=red>间隙锁（Gap Lock）</font>**机制。当一个事务读取范围数据时，InnoDB会对数据范围之间的间隙进行加锁，防止其他事务在这个范围内插入新的数据。

通过以上步骤，InnoDB在可重复读隔离级别下实现了对幻读的防止。事务在读取数据时使用快照来保证一致性视图，同时使用锁机制和间隙锁来阻止其他事务的并发修改和插入，从而避免了幻读问题的发生。

#### 6. MVCC实现机制前提概要

> MVCC解决了什么问题？如果没有MVCC会出现什么样的问题？

​	在数据库并发读读、读写、写写的场景中。读读操作是没有事务问题的，==读写操作可能会出现造成脏读、幻读、不可重复读的问题==。写写操作也是非同样会造成事务问题。有两个方案可以解决读写操作的事务问题：

1. 读、写都采用加锁（排它锁）的方式；
2. MVCC，mvcc中读操作不会阻塞其他读写操作，写操作中不会堵塞普通读（select）操作，且保证了一致性和隔离性；

因为方式1读写都加锁了，影响性能；方式2提高了并发能力，性能更好。

**共享锁和排他锁**

共享锁：Shared locks，在事务要读取一条记录时，需要先获取该记录的S锁；

```sql
#这类是共享锁
select ... lock in share mode;
```

独占锁：Exclusive locks，也称排他锁，在事务要改动一条记录时，需要先获取该记录的X锁；

```sql
#这类是排他锁
select ... for update;
update;
insert;
delete;
```



### 索引

### 日志

### 锁