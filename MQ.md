### MQ常见协议

#### JMS 

> java messaging service；是java面向消息服务的技术规范，ActiveMQ是该协议的典型实现；

#### AMQP 

>advanced message queuing protocol；一个提供统一消息服务的应用层标准，是应用层协议的一个开放标准。RabbitMQ是它的典型实现；

#### STOMP 

> streaming text orientated message protocol；面向流文本的消息协议 ActiveMQ是它的典型实现；

#### MQTT 7

> message queuing telemetry transport；一种二进制协议，主要用于服务器和低功耗物联网设备间的通信。

### MQ对比

#### Kafka基本概念

- broker 代理: 可以看作是一个独立的kafka服务器，多个kafka broker 组成一个kafka cluster；
- topic 主题：生产者将消息发送到指定topic，消费者订阅特定topic消费消息；
- partition 分区：partition属于topic一部分，一个topic可以有多个partition。并且同一topic下的partition可以分布在不同的broker，也就是说一个topic可以横跨多个topic；Kafka通过分区来实现数据冗余和伸缩性。

#### 生产者3个必要的配置

- bootstrap.servers：broker的地址，格式为 host:port 如果为集群，用`，`隔开；
- key.serializer：key的序列化格式；
- value.serializer：value的序列化格式；

#### 同步/异步发送消息

```java
//send方法提供异步和同步两种发送消息模式；
//同步
kafkaProducer.send(new ProducerRecord< >("topic", "msg")).get();
//异步
kafkaProducer.send(new ProducerRecord<>("topic","msg"), new Callback() {
  @Override
  public void onCompletion(RecordMetadata metadata, Exception exception) {
    //没有异常，发送成功
    if (exception == null) {
    }else {
      //记录异常等；
    }
  }
});
```



#### 生产者的重要配置：

**acks**：ack参数指定了必须要要有多少个分区副本收到消息，生产者才会认为消息是写入成功的。这个参数对**生产者端消息丢失**重要；

- ack=0, 不会确认服务器是否收到消息（不知道消息丢失），进而能提升发送消息的吞吐量；
- ack=1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。
    - 如果首领节点崩溃，新的首领还没有被选举出来，生产者会收到一个错误响应，生产者会重发数据；（**重发也是有限制的，见retries参数**）
    - 如果一个没收到消息的节点成为新首领，消息还是会丢失。
- ack=all

**retries:** 决定生产者重发消息的次数。如果达到这个次数，生产者会放弃充实并返回错误。

### RocketMQ 

[官网][https://rocketmq.apache.org/zh/docs/]

#### 消息丢失

- **生产者端**使用`事务消息机制`保证消息零丢失；

- **Broker**配置同步刷盘: RocketMQ提供了在Broker配置中设置同步刷盘的选项。在同步刷盘配置生效后，Broker在接收到生产者发送的消息后，会立即将消息`持久化到磁盘上的CommitLog`文件，并等待刷盘完成后再返回确认消息给生产者。

- **消费者端**使用同步消费机制: 在消费者端，选择使用`同步消费机制来确保消息不丢失`。在同步消费模式下，消费者一次只消费一条消息，并等待消息处理完成后再继续下一条消息的消费。

#### 消息的重复消费

> 举例：生产者生产一个订单消息，短信消费组需要发送短信给用户通知订单，积分消费组则需要增加积分等；而这个订单已经被这两个消费组消费后： 
>
> 1. 由于网络异常或消息传输失败或超时，生产者可能会重新发送消息；
> 2. 消费者应用或异常退出或重启它可能会重新从上一次消费的位置开始消费消息；
> 3. 消费者组变更或消费者实例变更，例如新增或溢出消费者实例，RocketMQ会重新负载均衡，这个过程，可能已经消费的消息会被重新分配给新的消费者实例。都会产生消息的重复消费问题。
>
> 解决方法如下：

1. 幂等，消费任意次消息所产生的影响与执行一次产生的效果一致。
2. 使用消息的唯一标识，可以根据消息的唯一表示来判断是否已经消费过改消息，例如存放在redis中，不为空则代表消费过；

#### 消息堆积

> 消息堆积又分为 **Producer端生产过快**/ **Consumer消费过慢**；

Consumer端消息堆积：

1. 增加消费者实例；
2. 调整消费者组的消费速率，如增加消费线程数，并发度等；
3. 优化消费端的处理逻辑；



#### 顺序消费消息

> 顺序消息分为**局部顺序**和**全局顺序**（吞吐量和性能太差，如要保证全局顺序建议别用mq了）；

1. **Producer端**顺序发送：确保需要顺序发送的消息发送在同一个队列（局部顺序）。（针对需要顺序的消息使用相同key等，再哈希取模发送指定topic，*但是随着topic的创建或服务不可用，哈希改变后也会导致不是顺序发送*）
2. **Consumer端**顺序消费：每个消费者线程只消费一个消息队列中的消息，这样保证消息的顺序性。当消费者线程正在处理一条消息时，不会继续消费其他消息，直到当前消息处理完成。

#### 事务消息机制

> ![事务消息](./MQ.assets/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png)
>
> 1. 生产者将消息发送至 rocketMQ 服务端;
> 2. rocketMQ 服务端将消息持久化成功之后，向生产者返回`ACK`确认消息已经发送成功。此时消息被标记为**暂不能投递**，这种状态下的消息即为**半事务消息**;
> 3. 生产者开始执行本地事务逻辑。
> 4. `生产者`根据本地事务执行结果向服务端`提交二次确认结果`（Commit或Rollback），服务端收到确认结果后处理逻辑如下：
>     - 二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。
>     - 二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。
> 5. 在断网或者是生产者应用重启的特殊情况下，若服务端未收到生产者提交的二次确认结果，或服务端收到的二次确认结果未unkonwn未知状态，经过固定时间，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。
> 6. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
> 7. 生产者根据检查到的本地事务的最终状态再次提交二次确认，根据确认结果对事务消息进行处理。