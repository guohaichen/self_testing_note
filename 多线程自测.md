### 线程的状态

> 线程的状态可以结合Java代码中调用什么方法会进行线程状态的切换。例如：`this.wait()`会使得当前线程进行waiting状态。`this.notify()`会唤醒其他线程，使得其他线程进入runnable状态；

1. **new**：创建但还未调用start方法；
2. **runnable**：运行状态，可能在运行，可能在等待操作系统调度；
3. **blocking**：阻塞状态，等待获取锁状态；
4. **waiting**：等待其他线程显示唤醒；
5. **time waiting**：超时等待，可以在指定的时间后自行返回而不是像waiting一直等待；
6. **terminated**：终止状态，表示当前线程已执行完毕。

### Java创建线程的方式

1. 继承Thread类（Thread也是实现了Runnable接口）；
2. 实现Callable接口，重写call方法，带返回值；
3. 实现Runnable接口，重新run方法，没返回值；
4. 通过线程池创建；

### Java的一些锁

### 死锁

> 死锁是一种资源竞争的情况，其中每个进程都在等待其他进程释放资源。导致进程无法继续执行，造成资源浪费、性能下降直至系统崩溃；

代码显示：

```java
public class DeadLock {
    public static final Object lockF = new Object();
    public static final Object lockS = new Object();
    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lockF) {
                try {
                    System.out.println(Thread.currentThread().getName() + "\t持有lockF,等待lockS");
                    TimeUnit.SECONDS.sleep(2);
                    synchronized (lockS) {
                        System.out.println("lockS in");
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "thread A").start();

        new Thread(() -> {
            synchronized (lockS) {
                try {
                    System.out.println(Thread.currentThread().getName() + "\t持有lockS,等待lockF");
                    TimeUnit.SECONDS.sleep(2);
                    synchronized (lockF) {
                        System.out.println("lockS in");
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "thread B").start();
    }
}
```

死锁检测工具：例如使用到了jdk自带工具：`jconsole.exe`：

| ![image-20230622165749566](.\assets\image-20230622165749566.png) |
| ------------------------------------------------------------ |

**死锁发生条件：**（参考自操作系统）

1. 互斥条件：同一时刻，该资源只能由一个线程占有；
2. 占有和等待条件：已经得到某个资源的线程正在等待获取一个被其他线程持有的资源；
3. 不可抢占条件：已经分配的资源不能从相应的线程中被强制剥夺；
4. 环路等待条件：两者线程相互持有对方的资源并等待对方的资源；

### 线程池

使用**线程池的优点**：

1. 降低资源消耗：池化技术，重复利用已创建的线程；

2. 提高响应速度：不需要等线程创建再执行；

3. 提高线程的可管理性：使用线程池可以统一分配、调优和监控。

**线程池参数**：

- **corePoolSize 核心线程数**
- **maxmiumPoolSize 最大线程数**(针对max-core)
- keepAliveTime 线程存活时间
- unit 存活时间单位
- **handler 拒绝策略**
- threadFactory 线程工厂名字
- **workQueue 阻塞队列**

当向线程池中提交一个任务时，线程池中的处理流程：

> 1. 线程池判断当前运行的线程数是否小于 < corePoolSize,如果小于，则创建线程执行任务，如果都在执行任务，则执行下一阶段；
> 2. 判断工作队列是否已满，如果工作队列没有满，则将该任务队列放入工作队列中，如果工作队列满了，则进行下一阶段；
> 3. 判断线程池是否已满，如果没有满，则创建一个新的线程来执行当前任务，在执行完该任务后，会反复从工作队列中获取任务来执行；
> 4. 如果线程达到maxmiumPoolSize，仍然有新任务这时会执行拒绝策略。

**拒绝策略jdk提供了4中实现**：

- `AbortPolicy` 默认策略，让调用者抛出 RejectedExecutionException(*拒绝执行异常*);
- `CallerRunPolicy` 让调用者运行任务；
- `DiscardPolicy` 放弃本次任务；
- `DiscardOledstPolicy` 放弃队列中最早任务，当前任务取而代之；



**关闭线程池**

- `shutdown`：将线程池状态变为shutdown，不会接受新任务，但是已提交的任务会执行完，且不会阻塞调用线程的执行；
- `shutdownNow`：将线程池状态变为stop，不会接受新任务，会将队列中的任务返回，并使用interrupt的方式中断正在执行的任务；

### Java内存模型

### volatile

### synchronized

### ThreadLocal

### AbstractQueuedSynchronizer

### 一些线程安全的集合