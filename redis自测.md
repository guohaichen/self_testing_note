### redis内存篇

#### **键的过期删除策略和内存淘汰机制**



### redis线程模型

> redis是单线程吗？为何单线程还这么快？

​	Redis单线程指的是`使用一个主线程来处理所有的客户端请求和执行命令并响应客户端`这个过程。但 redis 的其他功能，例如持久化、异步删除、集群数据同步等，redis会使用额外的线程来执行。

**redis快的原因：**

1. redis刚刚提到的单线程，避免了==锁的竞争，和线程上下文的切换==带来的额外开销，这是 redis 单线程快的原因之一;
2. ==redis的读写是基于内存的==，内存的读写效率本身就很高且redis有高效的==数据结构==（例如跳表，哈希表等）；
3. ==主线程通过IO多路复用来监听大量客户端的请求连接==，降低了资源消耗；

| ![](./redis自测.assets/why-redis-so-fast-d3507ae8.png) |
| :----------------------------------------------------: |

> 这里介绍IO多路复用技术，它是一种网络编程模型技术；最基础的tcp的socket编程，它是阻塞I/O模型，基本上只能1对1通信，为了服务更多的客户端，比较传统的方式是使用多进程/线程模式，每来一个客户端连接，就分配一个进程/线程。但是当客户端增大到上万个时，切换、调度这些线程又成为了问题，于是就出现了I/O多路复用，可以只在一个进程里处理多个文件的I/O，Linux下提供三种I/O多路复用的API,分别是select、poll、epoll。

#### 网络编程模型

1. **阻塞式**：在这种模型中，程序在发送或接收数据时会阻塞，直到操作完成；
2. **非阻塞式**：即使操作尚未完成，程序也可以发送或接受数据。程序通过轮询来检查操作是否完成，从而实现并发处理（问题：空转，资源浪费）。
3. **I/O多路复用模型**：这种模型使用操作系统提供的机制（如 `select`、`poll` 或 `epoll`）来同时监视多个套接字的状态。它允许程序同时处理多个连接，而无需进行轮询操作。
4. **异步IO模型**：异步模型使用回调函数或事件驱动的方式处理网络操作。程序发送请求后，可以继续执行其他任务，而不必等待响应。当操作完成时，系统会通知程序，触发相应的回调函数。

#### select、poll、epoll简述

1. select实现多路复用的方式是，将已连接socket都放到一个`文件描述符集合`,然后调用select函数将文件描述符集合`拷贝`到内核里。让内核检查是否有网络事件（通过`遍历集合`的方式）产生，当检查到有事件产生后，将此socket标记为可读或可写，再将整个文件描述符集`拷贝`回用户态，然后用户态再遍历的方法找到可读或可写的socket。整个select过程，需要`2次遍历`文件描述符，而且还有发生`2次拷贝`文件描述符集合。而且select使用的文件描述符集合在linux系统中，由内核中的FD_SETSIZE最大值为 `1024`，只能监听 0~1023 个文件描述符。poll 用来存储文件描述符改用了动态数组，以`链表`形式组织，突破了select的文件描述个数限制。
2. epoll在内核里面使用`红黑树`关注进程所有待检测的socket，通过对红黑树的管理，不需要像select/poll在每次操作时都传入整个socket集合，减少了内核和用户空间大量的数据拷贝和内存分配。epoll使用事件驱动的机制，内核里维护了一个`链表`来记录`就绪事件`，只将有事件发生的socket集合传递给应用程序，不需要像select/poll那样轮询扫描整个集合。

### redis持久化

​	redis是基于内存的，与memecached不同的是，redis提供了两种持久化数据的方式，分别为**`AOF`**和**`RDB`**以及在redis6后新出的**`mixed`**，包含AOF和RDB;

​	redis启动redis时，会优先加载aof文件，因为aof里面的文件更完整，如果aof文件不存在，则会去找rdb文件，从rdb文件恢复数据来启动，如果没有rdb文件，则直接启动；

#### AOF append-only file

​	AOF持久化是通过保存redis服务器所执行的`写命令`来记录数据库状态的，由参数appendonly yes/no控制。并且aof追加写由三个参数控制。当aof文件越写越大时，redis提供了aof`重写机制`，当aof文件的大小超过了设定的阈值后，就会启用aof重写机制，来压缩aof文件。AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件（重写aof文件也是由子线程完成的，不阻塞主线程）。

```xml
appendfsync everysec 	//默认 每秒将aof_buf缓冲区同步到aof文件中，丢失1秒数据的风险
appendfsync no				//不主动将aof_buf同步到aof文件，交由操作系统决定何时异步的将aof_buf同步到aof文件。也会增加数据丢失的风险
appendfsync always		//在每个redis写入命令后会强制将aof_buf写入aof文件，每个写命令都需要写回硬盘，磁盘io开销大
```

#### RDB snapshot

​	redis将内存中的`快照`通过二进制的形式写入到磁盘文件已到达数据持久化。提供了两个命令来创建rdb文件，`save`和`bgsave`，save 会**阻塞**主线程的操作,直到rdb文件创建完毕。bgsave 是主线程fork一个子线程，通过子线程来创建rdb文件，主线程将继续处理请求命令。

​	在redis配置文件中，提供了三种配置来实现每隔一段时间，自动执行bgsave。

```xml
save 900 1  	//900秒内，至少进行了一次修改，执行bgsave
save 300 10 	//300秒内，至少进行了10次修改，执行bgsave
save 60 10000 //60秒内，至少进行了10000次修改，执行bgsave
```

#### aof和rdb的一些对比

1. redis加载rdb文件恢复数据速度要远快于aof文件；但数据完整度不如aof，aof支持秒级的持久化；
2. rdb文件是二进制的，没有可读性；aof是普通的文本文件；
3. rdb的文件大小要小于aof文件，虽然两者都有一些压缩机制，如rdb会有压缩算法，aof会有bgrewriteaof机制；

### redis高可用

#### 主从复制

> 单机redis存在单点风险。为保证redis的高可用，最简单的方式就是使用`主从复制`扩展redis，主节点 master 主要负责写请求， 从节点 slave 主要负责读请求和来自 master 的请求（redis 是自带读写分离的，可以通过参数`save-read-only yes` 控制slave只读）。`主从复制`就是将一台主节点的数据复制到其他的redis从节点中。尽最大可能保证**主从的数据一致**。**Redis Sentinel 和 Reids Cluster 都依赖于主从复制。**
>
> 通过在从节点配置文件钟加入参数 slaveof/replicaof master'ip port 实现；

**主从复制同步方式：**

- 全量同步：比如第一次同步时，master通过bgsave生成rdb文件，slave接收传输过来`rdb文件`进行同步。
- 增量同步：正常的主从复制过程中，主节点将写的命令发给从节点，从节点执行相同的命令。增量同步是基于`复制缓冲区（Replication buffer）`

#### Redis Sentinel

> redis Sentinel是redis自带的高可用解决方案。它通过监控主节点和自动故障转移来实现高可用。当主节点发生故障时，sentinel会自动选举一个新的主节点进行切换。

**Sentinel作用：**

- **集群监控**：监控所有redis节点（包括sentinel节点自身的状态是否正常）==通过心跳机制检测==。
- **故障转移**：如果一个master出现故障，Sentinel会帮助我们实现故障转移，自动将某一个slave升级为master，确保整个redis的可用性。
- **消息通知**：通知slave新的master连接信息，让他们执行replicaof/slaveof成为新的master的slave;
- **配置中心**：如果故障转移发生了，通知客户端新的master地址。

**Redis Sentinel中有两个下线概念：**

​	**主观下线：**sentinel节点认为某个redis节点已经下线（心跳检测机制）。

​	**客观下线：**超过半数的sentinel节点认为某个redis节点已经下线。

一旦sentinel发现master故障，sentinel需要在salve中选择一个作为新的maset，选举依据：

- slave节点与master节点的断开时间长短；
- slave节点的slave-priority优先级，越小优先级越高；
- 最近一次的offset，越大优先级越高；

#### Redis Cluster



### redis应用

#### 缓存穿透

#### 缓存击穿

#### 缓存雪崩

### redis数据结构及实现概括

> redis共有5种基本数据结构: String，Hash, Set, Sorted Set, List;

#### 1. String

String类型并没有使用 C语言的字符串，而是由`SDS`实现，SDS 对比c语言原生字符串，具有以下优势：

1. <font color='red'>常熟复杂度O(1)获取字符串长度</font>，因为sds内部维护了一个len属性；
2. <font color=red>杜绝了缓冲区溢出</font>，正是由于c字符串不计长度，拼接字符串长度时，可能会造成数溢出，而sds会先检查空间是否足够，不够的话扩展空间；
3. <font color =red>减少修改字符串时带来的内存重分配次数</font>,例如使用`空间预分配`、`惰性释放`两种优化策略；
4. <font color =red>二进制安全</font>，c字符串通过判断空字符串是否到达结尾（字符串中不能包含空格，限制使得c字符串只能保存文本数据），而sds使用len的属性判断字符串是否结束；
5. <font color=red>兼容部分c字符串函数；</font>

#### 2. List

List是一个**双向链表**，是一种有序、可重复的数据结构；Redis的list支持在头部和尾部进行插入、删除和查询操作。

List类型的底层数据结构是由`双向链表或压缩列表`实现：如果元素个数小于512个，且列表每个元素的值都小于64字节，Redis会默认使用压缩列表作为List类型的底层数据结构；如果不满足这个条件，则使用双向链表作为实现；

在Redis3.2版本后，List数据类型的底层数据结构就只由`quicklist`实现，替代了双向链表和压缩列表。

- 用法举例：栈、队列、最近联系人、最近文章等；
- 相关命令：`lpush` `lpop`

#### 3. Hash

Hash是一种键值对的无序集合的数据结构。Redis中，Hash用于存储和操作具有key-value的对象的数据结构。Hash允许通过字段来快速查找和访问值。

Hash类型的底层数据结构是由`压缩列表或哈希表`实现；如果哈希类型元素个数小于512个，所有值小于64字节的话，redis会使用压缩列表作为底层数据结构；如果不满足这个条件，则使用哈希表作为实现；

在redis7.0中，压缩列表数据结构以及被废弃了，由`listpack`数据结构实现；

- 用法举例： 存储用户信息、商品信息、对象等；
- 相关命令：`hmset`一次存储对象的多个kv，`hset`修改制定对象的key, `hgetall`获取对象的所有键值对

#### 4. Set 集合

Set类型是一种无序集合，集合中的元素没有先后顺序但都唯一；

Set类型的底层数据结构是由`哈希表或整数集合`实现；如果集合中的元素都是整数且元素个数小于512个，redis会使用整数集合作为Set类型的底层数据结构。不满足这个条件，则使用哈希表作为Set类型的底层数据结构。

- 用法举例：可以基于Set轻易实现交集、并集、差集的操作。这样，就可以非常方便的实现共同关注、共同粉丝等；

- 相关命令：`sadd`向指定集合添加一个或多个元素 `smembers`获取指定集合的所有元素 `sinter key1 key2`获取所有集合的交集 `sunion key1 key2`获取所有集合的并集

#### 5. Sorted Sort 有序集合

Soterd Set是一种特殊的集合，其中的每个成员都关联着一个分数score, 并且成员按照分数的大小进行排序。Sorted Set 允许快速地根据成员获取、插入和删除操作，并且支持范围查询和根据分数进行排名。

Sorted Set类型的底层数据结构是由`压缩列表或跳表`实现的；如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用压缩列表作为底层数据结构；如果不满足这个条件，则使用跳表实现；

在redis7.0中，压缩列表数据结构以及被废弃了，由`listpack`数据结构实现；

- 用法举例：利用该score可以做排行榜，微信步数排行榜，话题榜等；

- 相关命令：`zrange`从小到大指定排序 `zrevrange`从大到小排序 `zrevrank`指定元素排名