- [innoDB](#innodb)
  - [1. MySQL存储引擎的对比](#1-mysql存储引擎的对比)
  - [2. 介绍一下数据库的事务](#2-介绍一下数据库的事务)
  - [3. InnoDB是如何实现ACID的](#3-innodb是如何实现acid的)
  - [4. 并发事务带来了哪些问题?](#4-并发事务带来了哪些问题)
  - [5. 事务的隔离级别有哪些?InnoDB默认的事务隔离级别？分别会导致哪些问题？](#5-事务的隔离级别有哪些innodb默认的事务隔离级别分别会导致哪些问题)
  - [6. MVCC实现机制前提概要](#6-mvcc实现机制前提概要)
  - [7. InnoDB引擎介绍](#7-innodb引擎介绍)
- [索引](#索引)
- [日志](#日志)
  - [**bin log**](#bin-log)
  - [**redo log**](#redo-log)
  - [**undo log**](#undo-log)
  - [redo log 和 undo log的区别？](#redo-log-和-undo-log的区别)
  - [**错误日志**](#错误日志)
- [锁](#锁)
- [补充](#补充)
  - [B+树高度为3，能存放多少数据？](#b树高度为3能存放多少数据)


### innoDB

#### 1. MySQL存储引擎的对比

MySQL的存储引擎有InnoDB，MyISAM；InnoDB是MySQL5.5之后默认的存储引擎，它相比MyISAM具有如下特点：

1. 支持事务
2. 支持外键约束
3. 支持表锁和行级锁，而MyISAM只支持表锁

#### 2. 介绍一下数据库的事务
事务是一组原子性的SQL查询，事务内的语句，要么全部执行成功，要么全部执行失败。

InnoDB是一个支持ACID事务的存储引擎。ACID分为为一致性、隔离性、持久性、原子性。 

**一致性**：事务完成时，必须所有的数据都保持一致状态，例如A给B转账，A扣费的同时且B要入账；

**隔离性**：事务执行过程中，事物间的操作对对方来说是不可见的；

**持久性**：事务执行完成后，对数据库的修改是永久保存的；

**原子性**：事务是一个原子操作单元，要么全部成功，要么全部回滚到事务开始前的状态，如果事务中的任何一步失败，整个事务将回滚，以保证事务的一致性；

#### 3. InnoDB是如何实现ACID的

通过 mvcc +锁机制实现隔离性，通过 redo log二进制日志实现持久性，使得能在断电，宕机情况下自动恢复数据，通过 undo log回滚日志实现原子性，这三特性实现才能实现数据的一致性；

通过 **mvcc+锁机制实现事务的隔离性**；通过redo log二进制日志实现持久性，使得能在断电，宕机情况下自动恢复数据；通过undo log回滚文件实现原子性；这三特性实现才能实现数据的一致性；
#### 4. 并发事务带来了哪些问题?

- **脏读**：一个事务读取到了另一个未提交事务的数据；

- **不可重复读**：在一个事务中，多次读取同一个数据可能得到不同的结果，这是由于读取到了另一个事务对数据的<font color='red'>修改或删除</font>；
- **幻读**：指在当前事务中，另一个并发事务<font color=red>插入</font>了一些数据并提交，随后在当前事务中，查询出之前本没有的数据，好像出现了幻觉，称之为幻读；
- **丢失修改**：当两个事务对同一数据进行修改时，并且最终只有一个事务生效时，另一个事务的修改丢失，称之为丢失修改；
- **死锁**：两个事务持有对方需要的资源，互相等待，称之为死锁，需要数据库管理系统检测并释放；

#### 5. 事务的隔离级别有哪些?InnoDB默认的事务隔离级别？分别会导致哪些问题？

- **读未提交RU**：一个事务中可以读取另一个事务未提交的数据；
- **读已提交RC**：一个事务中能读取另一个已提交事务的数据；（当前读）
- **可重复读RR**：一个事务只能读取当前事务的数据；（默认）（快照读）
- **串行读**：事务串行化执行，绝对的数据安全，效率最低；

| 隔离级别/并发事务问题 | 脏读 | 不可重复读 | 幻读 |
| --------------------- | ---- | ---------- | ---- |
| 读未提交              | √    | √          | √    |
| 读已提交              | ×    | √          | √    |
| 可重复读              | ×    | ×          | √    |
| 串行化读              | ×    | ×          | ×    |

**InnoDB默认的事务隔离级别为可重复读，并且使用MVCC+锁解决了幻读的问题；**

详细步骤：

1. 读取时加锁：当一个事务开始读取数据时，InnoDB会对所涉及的数据进行加锁，以确保在事务结束之前其他事务不能修改这些数据。这种锁为**<font color = red>共享锁（S锁）</font>**,允许多个事务同时读取同一数据行，但阻止其他事务对数据进行修改；
2. 写入时加锁：当一个事务开始写入（插入、删除或更新）数据时，InnoDB会对所涉及的数据进行加锁，以防止其他事务同时读取或写入数。这种锁称为**<font color = red>排他锁（x锁）</font>**,它在事务结束之前会阻止其他事务对数据行的读取和写入。
3. 生成快照：在可重复读隔离级别下，InnoDB会为每个事务生成一个**快照**（Snapshot），用于读取数据时保持一致性视图。
4. 版本控制：当一个事务开始读取数据时，InnoDB会根据**<font color=red>事务的启动时间和快照</font>**来确定可见的数据版本。只有在事务启动前已提交的数据版本才是可见的，未提交的或在事务启动后修改的数据版本对于当前事务是不可见的。
5. 防止幻读：InnoDB在可重复读隔离级别下还使用了**<font color=red>间隙锁（Gap Lock）</font>**机制。当一个事务读取范围数据时，InnoDB会对数据范围之间的间隙进行加锁，防止其他事务在这个范围内插入新的数据。

通过以上步骤，InnoDB在可重复读隔离级别下实现了对幻读的防止。事务在读取数据时使用快照来保证一致性视图，同时使用锁机制和间隙锁来阻止其他事务的并发修改和插入，从而避免了幻读问题的发生。

#### 6. MVCC实现机制前提概要

> MVCC解决了什么问题？如果没有MVCC会出现什么样的问题？

​	在数据库并发读读、读写、写写的场景中。读读操作是没有事务问题的，==读写操作可能会出现造成脏读、幻读、不可重复读的问题==。写写操作也是非同样会造成事务问题。有两个方案可以解决读写操作的事务问题：

1. 读、写都采用加锁（排它锁）的方式；
2. MVCC，mvcc中读操作不会阻塞其他读写操作，写操作中不会堵塞普通读（select）操作，且保证了一致性和隔离性；

因为方式1读写都加锁了，影响性能；方式2提高了并发能力，性能更好。

**共享锁和排他锁**

共享锁：Shared locks，在事务要读取一条记录时，需要先获取该记录的S锁；

```sql
#这类是共享锁
select ... lock in share mode;
```

独占锁：Exclusive locks，也称排他锁，在事务要改动一条记录时，需要先获取该记录的X锁；

```sql
#这类是排他锁
select ... for update;
update;
insert;
delete;
```

#### 7. InnoDB引擎介绍

> **逻辑存储架构**：表空间tablespace —— 段segment —— 区extent —— 页page —— 行row；

- 每张表都会有一个表空间（ibd文件），用于存储数据和索引；

- 段是**表空间的逻辑存储单元**，表示一个连续的数据结构。InnoDB有两种数据类型：数据段和索引段。数据段存储表的数据，索引段存储表的索引，每张表对应一个数据段和一个或多个索引段；
- 区是段的子单位，用于**分配和管理存储空间**。每个区的大小通常为1MB（64*页大小16KB），每个区可以容纳64个页，当需要分配新的空间给段时，**InnoDB以区为单位进行分配**；
- **页是InnoDB最小的存储单元,通常大小为16KB**，数据和索引都以页为单位存储在缓冲池和磁盘中。在磁盘上，也是按照连续的方式存储的，称为连续页（Sequential Page）。在缓冲池中，页以LRU链表的形式进行管理，称之为缓冲页（Buffer Page）。InnoDB**以页作为磁盘和内存交换的基本单位**。

- 行是表中的记录，包含实际的数据。行包含一些默认的字段，例如行标识符，版本号，回滚指针，事务ID；

通过这个逻辑存储架构，InnoDB能够高效的管理是组织表的数据和索引。提高了高并发性、事务支持和数据一致等；	

> **InnoDB内存架构**:主要包含缓冲池 `Buffer Pool` 、重做日志缓存日志`Redo Log Buffer`、自适应哈希索引`Adaptive Hash Index`、`Change Buffer`、`LRU管理`；

**Buffer Pool**

​	缓存池 Buffer Pool 用于在内存中缓存表数据和索引数据（从磁盘读取的**数据页**缓存在内存中->**缓存页**），以提高读取和写入性能；其大小可以通过`innndb_buffer_pool_size`设置；缓存池使用LRU(Least Recnetly Used)算法来管理数据页的使用；

​	当需要从磁盘中读取数据页时，InnoDB会首先检查数据页是否在缓存池中，如果在，直接返回给查询操作，否则则将从磁盘读取几个数据页到缓存池中。如果Buffer Pool空间不够，则采用LRU算法淘汰一些缓存页；

**缓存页**分为:

- dirty page: 使用过，并且已经修改过的缓存页;并存在于 Flush、LRU 链表；
- free page: 未被使用过的空闲缓存页；并存在于 Free 链表；
- clean page: 被使用过但数据未被修改的缓存页；存在于 LRU 链表；

普通LRU带来的问题

1. 预读失效：加载数据页时，会将邻近的数据页一起加载中Buffer Pool中，这些数据页会被加载在LRU链表的头部，实际不一定能用到，反而可能会频繁将用到的数据页淘汰，导致缓**存命中率降低**；InnoDB中将LRU分成了yong区，和old区；
2. Buffer Pool污染：当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了**，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。

**脏页刷盘的时机**

1. checkpoint检查点（比如redo log日志满时主动触发脏页刷盘），InnoDB会周期性地生成一个检查点。检查点之前的脏页都需要写回磁盘，以确保数据的持久性。
2. LRU，当Buffer Pool需要更多空间时，将会淘汰最近最少使用的数据页。在淘汰过程中，如果被选中的是个脏页，会先被写回磁盘并从Buffer Pool中移除；
3. 后台线程刷新，InnoDB有一个后台刷盘线程，负责定期将脏页异步刷新到磁盘。

**Redo Log Buffer**

> ​	这里需结合redo Log重做日志来看，已知redo log是为了保证数据一致性（脏页在还未刷盘的时候mysql服务挂了，重启mysql后，如果没有redo log文件，则事务提交前的修改丢失了。）而Redo Log Buffer的存在可以暂存事务执行期间产生的Redo Log日志记录，而通过一定的刷盘策略，再批量刷盘，减少磁盘的IO操作，提高性能。

### 索引

### 日志

**慢查询日志**

#### **bin log**

​	bin log 是由MySQL Server层实现的,bin log 是用来保证MySQL主从复制的日志，以二进制形式追加的全量文件（写满了重新新建一个文件开始写）。对比 redo log 和 undo log 是由innoDB层面实现的；bin log记录日志有三种格式，分别为 `row`,`statement`,`mixed`;

- statement: 记录的是sql语句原文；（问题:例如遇到 字段 = now()这种就会出现问题，导致主从的数据不一致；从而需要row格式）。

- row: 记录的是操作的具体数据，但是会占用更多的存储空间。
- mixed: 混合模式，会造成数据不一致的使用row，否则就是用statement格式；

#### **redo log**

​	重做日志，为了保证数据的一致性，InnoDB使用了 redo log 拥有了 `crash-safe`崩溃恢复的能力（这里指的是脏页在还没有落盘的时候MySQL服务挂了，磁盘的数据就没有被修改掉。有了redo log 文件组之后，mysql再次启动的时候，会将log文件写入数据，这时数据就和崩溃恢复前的脏页数据一致了）。

​	**redo log 的刷盘流程：**当修改数据时，如果Buffer Pool中存在包含该数据的页，会先修改数据页变成脏页，再写入redo log文件中，再刷盘，这个技术称为`WAL`write-ahead write：MySQL的写操作并不是立刻写到磁盘上，而是先写入到日志，然后在合适的时间写入到磁盘中（见刷盘策略） 。redo log 按照一定的策略进行刷盘。先记日志，再进行刷盘，有什么好处？1. 将`随机io`（磁盘修改数据）变成`顺序io`（redo log记录）; 2. `减少磁盘io`，可以将redo log批量的记录刷入到磁盘中，而不是每次都刷盘； 3. `提供事务的持久性和恢复能力`；

**redo log 的刷盘策略：**在InnoDB中并不是在每次修改的数据时写入 redo log 文件，为了提高性能，而是写入在 `redo log buffer` （默认值为16M）中。redo log buffer 缓存中的log写入redo log文件时，会有以下几个时机：

- redo log buffer**空间不足一半时**，会触发刷盘；
- InnoDB的**后台线程每隔1秒**，将redo log buffer持久化到磁盘；
- **每次事务提交时**都将缓存在redo log buffer的redo log直接持久化到磁盘（此策略由innodb_flush_log_at_trx_commit控制）

`innodb_flush_log_at_trx_commit`参数决定刷盘策略；有以下三个参数决定刷盘策略：[摘自官网](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)

- 0: Logs are written and flushed to disk once per second. Transactions for which logs have not been flushed can be lost in a crash.
- 1: Logs are written and flushed to disk at each transaction commit.完全符合ACID的要求；
- 2: Logs are written after each transaction commit and flushed to disk `once per second`. Transactions for which logs have not been flushed can be lost in a crash.

#### **undo log**

​	回滚日志，为了保证事务的**原子性**。在事务没提交之前，MySQL会记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log进行回滚；

#### redo log 和 undo log的区别？

两种日志是属于InnoDB存储引擎的日志，区别在于：

| 方面     | redo log                                                 | undo log                                                     |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 功能方面 | 记录对数据的增删改操作，用于恢复到数据库到宕机前的状态。 | 记录增删改之前的操作，例如增加就记录删除，用于事务回滚和配合mvcc避免幻读； |
| 存储位置 | 以循环写入的方式存储在磁盘上的redo log文件。             | 通常存储在临时表空间或者俞数据文件一起存储；                 |

#### **错误日志**

### 锁

### 补充

#### B+树高度为3，能存放多少数据？

> 在Innodb存储引擎中，一个`页`大小为`16KB`，页中存储的是`行`，每个叶子节点都是一页；
>
> 假设一行数据为`1KB`，那么一个**节点**（b+树中指叶子节点，叶子节点才存放数据）就能存放16行数据。
>
> **非叶子节点**存放的是主键值和指针，假设主键类型设置为bigint，占用8byte，指针假设为6byte，**总共14byte**，得出根节点下能存储16KB/14byte=1170个指针，指向叶子节点；
>
> 由此，2层b+树，根节点能存放叶子节点数量为1170个，可以存放 1170（页） * 16（一页16行数据） = 18720 行数据。3层B+数，可以存放 1170\*1170\*16 = 21902400行数据，差不多2000w条数据；
